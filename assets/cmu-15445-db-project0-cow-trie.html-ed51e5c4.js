import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as r,c as t,f as o}from"./app-d87bac5c.js";const c={},a=o('<h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction" aria-hidden="true">#</a> Introduction</h2><p>We support bar feature, ...</p><h2 id="task-1-copy-on-write-trie" tabindex="-1"><a class="header-anchor" href="#task-1-copy-on-write-trie" aria-hidden="true">#</a> Task #1 - Copy-On-Write Trie</h2><p>Get方法：由于不需要修改节点，因此Get方法最为容易从上到下遍历Trie，找到最后一个节点后Convert成TrieNodeWithValue，如果convert完为nullptr就返回nullptr，否则就获取对应值就可以。</p><p>Put方法：从上往下遍历Trie，边遍历边新建节点，这是一般会先想到的思路。但是由于TrieNode的map存储了<code>std::shared_ptr&lt;const TrieNode&gt;</code>表示了无法通过shared ptr修改TrieNode的值，因此 需要通过Clone获取non const的TrieNode，不存在的节点需要make_shared创建，沿途节点进栈。反向遍历key字符串，并pop出stack中的节点，连接节点。</p><p>Remove操作：从上到下遍历，由于最后的节点删除可能导致父亲以及祖先节点被删除，因此我们要记录路径上的所有节点到stack中，这里同理要Clone节点，到了最后一个节点先判断是否存在值， 如果不存在直接返回；如果存在，不能用Clone，不然类型还是TrieNodeWithValue，需要创建一个新的TrieNode。再从后向前遍历key字符串，将所有节点一一对应的弹出stack，利用两个指针child和 parent，修改parent的<code>children_</code>这个map组装parent和child保证clone后的children_[ch]指向了新的clone的child而不是旧的。还需要额外判断child的是否还有children，如果没有，就可以在 parent中erase掉对应的child的char。</p>',6),i=[a];function n(d,h){return r(),t("div",null,i)}const p=e(c,[["render",n],["__file","cmu-15445-db-project0-cow-trie.html.vue"]]);export{p as default};
